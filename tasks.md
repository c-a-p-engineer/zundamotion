# ✅ P0（必須・即効：まず入れると体感が変わる）

## 01. “copy concat” 採用（concatデマルチプレクサ）

**理由**

* いまはフィルタ版 `concat` で最終結合しており、**全編再エンコード**になって時間を食う。
* クリップの映像/音声パラメータを完全一致させれば、**無再エンコード結合**にできる（I/O時間≒結合時間）。

**実装**

* 全クリップを同一仕様（解像度、fps、pix\_fmt、プロファイル、音声フォーマット）で出力（→タスク04/05とセットで効く）。
* `list.txt` を生成して `ffmpeg -f concat -safe 0 -i list.txt -c copy final.mp4`。
* 不一致検出（メタ比較）時のみ再エンコード経路（従来パス）にフォールバック。

**完了判定**

* 連結対象が同一仕様なら、**再エンコードなし**で最終MP4が生成される。
* 1分程度の動画で、Finalize 所要が**秒オーダー**（≦3秒目安）になる。

---

## 02. クリップ出力パラメータ完全統一（映像）

**理由**

* “copy concat”の前提条件。パラメータ差異が1つでもあると再エンコードが走る。

**実装**

* ビルダーを1箇所に集約（`VideoParams` データクラス）。
* 既定：`1920x1080 / 30fps / yuv420p / H.264 Main / bt709` などをテンプレ化。
* コマンド例（H.264）: `-vf scale=1920:1080 -r 30 -pix_fmt yuv420p -profile:v main`。

**完了判定**

* どのシーンを出しても `ffprobe` で仕様が完全一致する。
* “copy concat” の**フォールバック率が0%**（期待）〜低率に抑えられる。

---

## 03. 音声規格の統一（48kHz/AAC）

**理由**

* 音声が24kHz/mono等で混在すると、映像はcopyでも**音声だけ再エンコード**になりがち。
* 先にTTS直後で規格化すれば、以後の処理が軽くなる。

**実装**

* 生成直後に `-ar 48000 -ac 2 -c:a aac -b:a 128k` へ正規化、または TTS出力自体を48kHz化。
* 正規化済み音声をキャッシュ（キー：テキスト＋TTSパラメータ＋規格値）。

**完了判定**

* すべてのクリップの音声仕様が**48kHz / stereo / AAC** で一致。
* Finalize 時に音声だけが原因の再エンコードが**ゼロ**。

---

## 04. 背景/挿入動画の Normalization キャッシュ

**理由**

* 同じBGや挿入動画を**シーンごとに毎回**正規化して無駄が出ている。
* 事前に1回だけ正規化してキャッシュすれば、以後は読み出しのみ。

**実装**

* 入力ファイル＋正規化パラメータ（解像度/fps/pix\_fmt/audio\_rate/コーデック）で**内容ハッシュ**を作り、`cache/normalized_{hash}.mp4` を作成。
* ヒット時は変換スキップ。ミスマッチ時のみ再生成。
* 正規化仕様はタスク02/03の統一値に合わせる。

**完了判定**

* 同一素材の2回目以降、正規化処理が**常にスキップ**される。
* 総時間比較で、素材再利用プロジェクトの初回→2回目において**前処理時間がゼロ**に近づく。

---

## 05. `-threads 1` 撤廃＋フィルタ並列

**理由**

* FFmpeg のデフォルト並列を殺すと、**CPUフィルタ処理が常に単スレ**になってしまう。

**実装**

* 共通オプションから `-threads 1` を削除し、**`-threads 0`** を既定。
* さらに `-filter_threads $(nproc) -filter_complex_threads $(nproc)` を付与（OS依存で過大なら上限設定）。

**完了判定**

* FFmpeg ログで `threads=auto` が効いている（x264/nvenc側も該当）。
* 既存プロジェクトで平均 `speed`（FFmpeg表示）が\*\*≥1.2×\*\* へ上昇。

---

## 06. NVENC 高速プリセット切替（Quality↔Speed）

**理由**

* 1650 Max-Q でも NVENC を正しく使えば、**CPUエンコードより高速**。
* 現状 `-preset fast`（x264想定）固定気味で最速域を活かし切れていない。

**実装**

* 既定エンコードに `-c:v h264_nvenc` を採用。
* CLI `--quality {speed|balanced|quality}` を追加し、

  * `speed`: `-preset p7` / `-cq 30`
  * `balanced`: `-preset p5` / `-cq 23`
  * `quality`: `-preset p4` / `-cq 20`
    のようにマップ（数値は運用で微調整）。

**完了判定**

* 1分程度の素材で、VideoPhase 所要が**x264比で 40〜60%** に短縮。
* 画質劣化が許容範囲（サンプル比較で破綻なし）。

---

## 07. CUDA hwaccel 明示と転送最小化

**理由**

* デコード→CPUフィルタ→再アップロードの**往復転送**が遅さの一因。
* 可能なフィルタは GPU 側で処理し、ダウンロード/アップロードを最小化。

**実装**

* 既定で `-hwaccel cuda -hwaccel_output_format cuda` を付与。
* GPU非対応フィルタ手前だけ `hwdownload`、終わったら必要なら `hwupload_cuda`。
* 将来的に `scale_npp`/`overlay_cuda` を使う準備（タスク27と接続）。

**完了判定**

* FFmpeg ログ上でフレーム転送の回数が**最小**になっている（フィルタグラフ確認）。
* 同一条件で CPU利用率が下がり、総時間が**5〜15%** 改善。

---

## 08. ジョブ並列（安全制御付き）

**理由**

* シーン横並びの**外側並列**が効いていない。
* NVENCセッション数やGPUメモリに応じて**同時数を管理**すれば、壁時計時間をさらに圧縮。

**実装**

* CLI `--jobs N`（既定1〜2）。
* `ProcessPoolExecutor(max_workers=N)` でシーン単位にFFmpegをディスパッチ。
* 実行中のジョブ数・VRAM使用量・失敗リトライ（指数バックオフ）を管理。

**完了判定**

* `--jobs 2` 程度で**総処理時間が明確に短縮**（目安：1.2〜1.6×）。
* セッション枯渇・失敗が適切にリトライ/フォールバックされる。

---

## 09. BGM適用と最終出力の統合

**理由**

* BGM適用を別フェーズでやると**中間I/O**が1回増える。
* Finalize でまとめて行えるケースは**一本化**した方が速い。

**実装**

* ワンパスで済む場合は Finalize の `filter_complex` に `amix/volume/afade` を合流。
* 難しいケース（多重BGMやSEの複合）は現行フローを残すが、判定を自動化。

**完了判定**

* 統合可能なケースで**中間ファイルが1本減る**。
* 該当プロジェクトで総時間が**数％〜10％台**短縮。

---

## 10. ワンパス `filter_complex` 生成器（中間I/O削減）

**理由**

* フェーズ分割で都度書き出し→読み込みするとI/Oが嵩む。
* トランジション/テロップ/合成を**一本のグラフ**で走らせると速いケースがある。

**実装**

* タイムライン長から各要素の開始/終了を計算し、`xfade`/`acrossfade`/`trim`/`overlay` を**自動で連結**するビルダーを実装。
* 分岐：

  * 「copy concat」可能なケースは copy 優先、
  * トランジション連続区間はワンパス、
  * それ以外は従来フローへフォールバック。

**完了判定**

* 同一内容で、**中間ファイル点数とI/O時間が減る**。
* 1分サンプルで Finalize 所要が**1/2〜1/3**。

---

## 11. ベンチ/メトリクス出力（CSV/MD）

**理由**

* 最適化を積むと回帰が見えにくい。
* 「変更 → 効果」を**数値で記録**し、退行を即検知したい。

**実装**

* 各フェーズ開始/終了秒・FFmpegの `speed/fps` を**CSV/JSON**に保存。
* しきい値（例：前回比+20%）超過で**警告ログ**。
* README/MDに直近3回のサマリを自動追記（任意）。

**完了判定**

* `perf/YYYYMMDD.csv` が生成され、PRごとに**改善/退行が可視化**。
* 退行警告が機能する（わざと重い設定で発火テスト）。

---

## 12. 出力解像度/アスペクトの明示指定（YAML/CLI）

**理由**

* Shorts（9:16）や1:1対応を正しく行い、**全レイアウト/字幕**を自動調整したい。
* 事前に仕様が決まっていれば、前処理/結合仕様も揃えやすい。

**実装**

* `meta.resolution`, `meta.aspect_ratio`、CLI `--resolution`, `--aspect-ratio` を追加。
* この値を**単一の `VideoParams`** に反映し、座標系・フォントサイズ・安全域を自動計算。

**完了判定**

* 9:16/1:1/16:9 のいずれでも**破綻のない配置**で出力できる。
* 仕様と異なる素材が入った場合、警告や自動正規化が働く。

---

# 🧩 P1（中規模：負荷削減＆表現力）

## 13. 字幕の事前レンダ（PNG化）

**理由**

* `drawtext` はCPUフィルタで重い。静的テキストは**画像合成**が速い。

**実装**

* Pillowで半透明ボックス込みのPNG/WEBPを生成。
* 時間制御は分割クリップ化 or `enable` 付き `overlay`。
* レイアウトは `VideoParams` に基づき自動配置。

**完了判定**

* 同一尺で `drawtext` 版より**クリップ生成が≥1.4×**。
* 文字縁/ボックス表現が要件通り。

---

## 14. 立ち絵の事前スケール

**理由**

* 毎フレーム `scale` するのは無駄。**使用倍率**で前処理しておけば軽い。

**実装**

* `characters/NAME/scale-{0.8,1.0,1.2}.png` などを生成（キャッシュ）。
* 合成時はスケールなしで `overlay`。

**完了判定**

* 同一シーンでフィルタグラフが**短縮**され、総時間が**数％〜10％台**改善。

---

## 15. 静的レイヤーの事前合成＋静止レンダモード

**理由**

* 背景＋立ち絵など**動かない組み合わせ**を毎フレーム `overlay` するのは無駄。

**実装**

* 事前に静止PNGへ合成し、必要なら `-loop 1` で動画化して再利用。
* CLI `--mode static` を追加して、該当シーンは `filter_complex` 未使用で `-map` のみ。

**完了判定**

* 静的シーンの生成が**極端に軽く**なる（I/O中心）。
* 画質差なし。

---

## 16. 部分再エンコード（トランジション領域限定）

**理由**

* 長尺全体を再エンコードするより、**クロスフェード部分のみ**再エンコードの方が速い。

**実装**

* A | Trans(A→B) | B の3分割。
* 真ん中だけ再エンコード、両端は `-c copy`。
* 最後に concat demuxer で **copy結合**。

**完了判定**

* トランジションが多い作品でも、**全体エンコード時間が線形に増えにくい**。

---

## 17. トランジション結果のキャッシュ

**理由**

* 同じA→B, 同じフェード量の**再生成**が発生する。

**実装**

* キー：`(hash(A),hash(B),type,duration,codec)` で `cache/transitions/` に保存。
* ヒット時は即 reuse。

**完了判定**

* 同じ並びの2回目以降、対象区間のレンダが**スキップ**される。

---

## 18. パラメータ/テンプレートの一本化（データクラス化）

**理由**

* 仕様ドリフト（箇所ごとの微妙な差）を**根絶**する。

**実装**

* `VideoParams/AudioParams` をデータクラス化、**全ビルダーが必ず参照**。
* 変換コマンドは単一の `CommandBuilder` に集約。

**完了判定**

* `ffprobe` 比較で各クリップの仕様が**完全一致**。
* “copy concat” フォールバックが**消える**。

---

## 19. 素材リゾルバ（事前存在チェック）

**理由**

* 実行途中の「ファイルなし」中断を**早期検知**したい。

**実装**

* 実行前に全アセットの存在・形式を走査→不足/非対応は一覧で警告。
* `--strict` でエラー終了モード。

**完了判定**

* 実行開始後の**ファイル欠損停止がゼロ**に近づく。

---

## 20. SE相対トリガー（line\_start/end基準）

**理由**

* 固定秒だと台詞変更で**合わせ直し**が発生する。

**実装**

* YAMLに `at: line_end - 0.2s` のような相対記法を追加。
* 実行時に絶対時刻へ解決し、`adelay/atrim` で実装。

**完了判定**

* 台詞尺が変わっても SE が**意図した位置**で鳴る。

---

## 21. シナリオ記法（二段構え）

**理由**

* 初心者には簡潔に、上級者には詳細に。**両立**させたい。

**実装**

* “簡易記法” → 既定値を自動補完、
* “詳細記法” → すべて明示指定、
* `script_loader` が両方を解決して内部モデルへ。

**完了判定**

* 簡易・詳細どちらのYAMLからも**等価な動画**が生成される。

---

## 22. 複数キャラ表示＆プリセットレイアウト

**理由**

* 1キャラ前提だと表現が限定的。
* 解像度に応じた**相対配置**がほしい。

**実装**

* `left/right/center/top-left...` の抽象位置を `VideoParams` から座標化。
* 2人会話の標準レイアウトをプリセット。

**完了判定**

* 9:16/1:1でも**崩れない**掛け合いレイアウトが一発で出る。

---

## 23. キャラ入退場アニメ（slide/fade/zoom）

**理由**

* 静止表示のみだと**単調**。

**実装**

* `slide_in`, `fade`, `zoom` などをプリセット化（`xfade`/`zoompan`/`setpts` 併用）。
* YAMLで `enter: {type: slide_in, dur: 0.4s, from: left}` のように指定。

**完了判定**

* プリセットだけで**意図通りの動き**が再現可能。

---

## 24. プロファイル切替（Speed/Balanced/Quality）

**理由**

* デバッグと本番で**求める品質/速度**が違う。

**実装**

* `profiles.yaml` で fps/preset/cq/threads/jobs を定義し、CLI `--profile` で切替。
* 既定は `Balanced`。

**完了判定**

* `--profile` の変更だけで**体感速度/画質**が切り替わる。

---

## 25. 失敗時フォールバック（NVENC→libx264）

**理由**

* NVENC セッション枯渇・ドライバ問題で**停止**しないように。

**実装**

* エラー検出で自動的に `-c:v libx264 -preset veryfast` へ降格、
* ログに**再現コマンド**を吐く。

**完了判定**

* NVENC失敗時でも**処理が継続**され、最終物が出る。

---

# 🛠️ P2（環境・拡張）

## 26. FFmpeg CUDA/NPP対応ビルド

**理由**

* `scale_npp`/`overlay_cuda` を使って**GPU側で完結**させたい。

**実装**

* CUDA/NPP有効なFFmpegを用意（Docker推奨）、`ffmpeg -filters` で機能確認。
* 既存のCIでも同一ビルドを配布。

**完了判定**

* `scale_npp`, `overlay_cuda` が**使用可能**で、速度が**さらに向上**。

---

## 27. GPUフィルタグラフ実装（scale\_npp/overlay\_cuda）

**理由**

* デコードだけGPUでフィルタはCPUだと**往復コスト**が残る。

**実装**

* `scale`→`scale_npp`、`overlay`→`overlay_cuda` へ置換。
* `drawtext` は画像合成（タスク13）へ移行してGPU合成。

**完了判定**

* 同一素材で**速度2×前後**の改善が見込める（プロジェクト依存）。

---

## 28. キャッシュキー/ダーティトラッキング

**理由**

* 古いキャッシュ混入で**不整合**が起きがち。

**実装**

* 入力/設定/FFmpeg版/コマンド列を連結してハッシュ生成。
* 変更検出で自動無効化。

**完了判定**

* 設定変更時に**必ず再生成**され、古い成果が紛れない。

---

## 29. DevContainer GPU自動検知

**理由**

* 環境ごとの差で**手作業切替**したくない。

**実装**

* エントリポイントで `nvidia-smi` などを検出→環境変数でプロファイルを切替。
* `NVIDIA_VISIBLE_DEVICES` が未設定ならCPU路線。

**完了判定**

* GPU有無で**自動**に最適経路が選ばれる。

---

## 30. FFmpegバージョン固定と検証ログ

**理由**

* 速度/挙動が**ビルド差**でブレる。再現性が必要。

**実装**

* Dockerfile でバージョン固定、`ffmpeg -buildconf` をログ保存。
* CIでも同じバージョンを配布。

**完了判定**

* 別環境でも**同等の速度/挙動**が再現できる。

---

## 31. CIベンチ（短尺サンプル計測）

**理由**

* PR毎に**退行検出**を自動化したい。

**実装**

* GitHub Actions で 15〜30秒のサンプルをレンダ→メトリクス（CSV/MD）をArtifacts/コメントへ。
* しきい値超過で失敗または警告。

**完了判定**

* 退行を**PR時点で発見**できる。

---

## 32. ドキュメント整備（高速化ガイド）

**理由**

* ユーザーが自身の環境で**最速設定**を選べるように。

**実装**

* `docs/performance.md` に「NVENC推奨設定」「ジョブ並列の目安」「トラブルシュート」を記載。

**完了判定**

* 新規ユーザーがガイドだけで**最速付近**を出せる。

---

## 33. 配布/実行環境（PyPI/Docker/CI）

**理由**

* 導入性・再現性・広まりのため。

**実装**

* `pyproject.toml` 整備、Docker イメージ配布、CIでビルド→公開。

**完了判定**

* `pip install zundamotion` / `docker run ...` で**即実行**できる。

---

## 34. 構成ログ出力（JSON/CSV）

**理由**

* 外部ツールで**タイムライン解析**したい。

**実装**

* 使用素材・トラック・時刻を `Timeline.save_as_json(csv=True)` で出力。

**完了判定**

* JSON/CSV から**完全再現**できる情報が揃う。

---

## 35. Shorts自動リフレーム（16:9→9:16）

**理由**

* 既存横動画を**縦に再利用**したい。

**実装**

* `--profile yt_shorts` で `crop/pad` と安全域の自動配置。

**完了判定**

* 16:9ソースから**破綻なく9:16**が生成される。

---

## 36. 拡張トランジション（wipe/slide/dissolve）

**理由**

* 視覚バリエーションを増やす。

**実装**

* `xfade` バリエーションの辞書化とYAML指定。

**完了判定**

* 新規タイプが**即使用**可能。

---

## 37. 自動サムネイル生成

**理由**

* 運用の手数を減らす。

**実装**

* 代表フレーム抽出＋タイトル合成（PNG事前レンダ）を出力。

**完了判定**

* 生成と同時に**サムネ画像**が得られる。

---

## 38. Viseme対応 & VRM連動（長期）

**理由**

* 口形や3D連動で**表現の天井**を上げる。

**実装**

* 音素→口形マップ→2D差分、将来はVRMモーションAPIへ。
* モジュール分離（オプション機能）。

**完了判定**

* 2D口形が**音素に同期**、将来はVRMの簡易連動が可能。
