# 📋 Zundamotion ログ解析後タスクリスト

## P0（必須・緊急対応）

### 02. 正規化キャッシュの自己再正規化防止

* **背景**: 正規化済みファイルを再び “Normalized miss” として扱っている。
* **ゴール**: 正規化済みファイルが再度処理されない。
* **実装イメージ**:

  * 入力ファイルと目標規格のハッシュキーでキャッシュ判定。
  * 正規化済みファイルには「正規化済みマーカー」またはメタ情報を付与。
  * `cache/temp_normalized_*.mp4` は正規化対象から除外。
* **確認方法**: 「Successfully normalized …」直後に “Normalized miss” が出ない。

### 03. フェーズ時間計測の実態反映

* **背景**: `VideoPhase.run` 等が `Duration: 0.00 seconds` で実処理時間を反映していない。
* **ゴール**: 各フェーズの実行時間がログに正しく表示される。
* **実装イメージ**:

  * `time.monotonic()` で開始〜終了を測定。
  * サブタスクごとの平均・最大・p95 を集計しサマリを出力。
* **確認方法**: `VideoPhase` が \~173 秒と正しく記録される。

---

## P1（重要・中期）

### 04. `--no-cache` 時の挙動とログ文言整理

* **背景**: `--no-cache` でも `cache/` 下に一時ファイルを生成しているため混乱。
* **ゴール**: ユーザーがログを見て「永続キャッシュを使っているか」を正しく理解できる。
* **実装イメージ**:

  * 永続キャッシュ OFF、エフェメラルキャッシュ ON の区別をログに表示。
  * 一時ファイルは `/tmp` 配下に明示的に保存。
* **確認方法**: ログで「Persistent=OFF / Ephemeral=/tmp/...」が確認できる。

### 05. 同一素材の重複プローブ抑止

* **背景**: `scene_bg_intro.mp4` や `countdown.mp4` が複数回プローブされている。
* **ゴール**: 同一素材は一度だけプローブされる。
* **実装イメージ**:

  * プローブ結果を dict でキャッシュ。
  * 同一パス＋同一規格要求なら即リターン。
* **確認方法**: 同一素材で “Normalized miss” が 1 回しか出ない。

---

## P2（改善・後回し可）

### 06. クリップ生成のスループット改善

* **背景**: 字幕合成付きクリップが 1 本あたり 8〜13 秒かかっている。
* **ゴール**: 1 クリップあたりの生成時間を半減。
* **実装イメージ**:

  * `-filter_threads` の最適化。
  * 前処理を正規化段階に集約し、clip 生成では overlay のみ。
  * 並列レンダリング（ProcessPoolExecutor）。
* **確認方法**: `VideoPhase` の総時間が \~50% 短縮。

### 07. ログの読みやすさ改善

* **背景**: 「成功？失敗？」が曖昧、また統計情報が出ない。
* **ゴール**: ログを読むだけで状態を正しく把握できる。
* **実装イメージ**:

  * `[Phase=Video][Task=RenderClip][Scene=intro][Idx=3/6]` のように KV 出力。
  * 最終サマリで「clips=18 avg=9.6s p95=13.2s」などを出力。
  * ffmpeg コマンド全文は DEBUG のみに。
* **確認方法**: 1 実行分のログを見ただけでボトルネックがわかる。


## P0（必須・最優先）


### 03. **NVENCスモークテストの冗長実行を抑制**

* **背景**: VideoPhase内で毎回 `Performing a quick smoke test for h264_nvenc...` が走っている。重複して無駄。
* **ゴール**: パイプライン全体で1回だけスモークテストを実行。以降はキャッシュされた結果を利用。
* **実装イメージ**:

  * モジュールスコープの変数 `nvenc_checked = False` を導入。
  * 初回だけテスト → 結果を保持。2回目以降はスキップ。
* **確認方法**:

  * ログで「smoke test」が最初の1回だけ表示されること。

---

## P1（高速化）

### 04. **字幕クリップ生成の高速化**

* **背景**: VideoPhaseで170秒。字幕PNG→動画焼き込みが直列で重い。
* **ゴール**: 字幕付きクリップ生成が並列処理され、処理時間が短縮。
* **実装イメージ**:

  * `ProcessPoolExecutor` でPNG生成を並列化。
  * overlay合成もまとめ処理を検討（drawtext/ASSの利用など）。
* **確認方法**:

  * 同じ素材で再生成したときに処理時間が半減する。

---

### 05. **キャッシュ有効化のデフォルト化**

* **背景**: `--no-cache` で毎回生成 → 無駄。
* **ゴール**: デフォルトではキャッシュ利用。差分だけ処理。
* **実装イメージ**:

  * `--no-cache` はデバッグ時のみ使用。
  * normalized素材や音声はハッシュ再利用。
* **確認方法**:

  * 2回目以降の実行が数十秒以内で完了する。

---

### 06. **VOICEVOX音声合成の並列化**

* **背景**: 複数のセリフの音声合成が直列で実行されている可能性がある。
* **ゴール**: 複数のセリフの音声合成を並列で実行し、処理時間を短縮する。
* **実装イメージ**:

  * `AudioPhase` 内で `asyncio.gather` などを使用して、複数の `generate_audio` 呼び出しを同時に実行する。
  * VOICEVOXサーバーの負荷やAPIレートリミットを考慮した並列化戦略を検討する。
* **確認方法**:

  * 音声合成にかかる時間が短縮される。

---

### 07. **FFmpegの並列処理の最適化とGPU活用**

* **背景**: RGBAオーバーレイがある場合にCPUフィルターにフォールバックしている。
* **ゴール**: RGBAオーバーレイを含む場合でもGPUフィルターを効率的に利用し、レンダリング時間を短縮する。
* **実装イメージ**:

  * RGBAオーバーレイを含む場合でもGPUフィルター（例: `overlay_cuda`）を効率的に利用できるようなFFmpegのバージョンや設定を検討する。
  * FFmpegコマンドの `-preset` や `-tune` オプションを調整し、エンコード速度を向上させる。
  * `normalize_media` 関数内での `-c copy` の適用範囲をさらに拡大し、不要な再エンコードを削減する。
* **確認方法**:

  * 動画レンダリングにかかる時間が短縮される。
  * GPU使用率が向上する。

---

## P2（将来的改善）

### 08. **音声エンコーダの自動フォールバック**

* **背景**: libmp3lameが無い環境でPCMに落ちてしまう。
* **ゴール**: 環境に合わせて `libmp3lame` / `aac` を自動切替。
* **実装イメージ**:

  * ffmpeg -encoders の出力をチェック。
  * libmp3lameが無ければ `aac` に切り替え。
* **確認方法**:

  * どの環境でも `pcm_s16le` ではなく圧縮音声で出力される。

---

### 09. **キャッシュ機構のさらなる活用と改善**

* **背景**: 現在のキャッシュはファイル単位だが、FFmpegのフィルターグラフの各ステップの中間結果もキャッシュできる可能性がある。
* **ゴール**: 中間結果のキャッシュにより、複雑なフィルターグラフの再計算を避ける。
* **実装イメージ**:

  * FFmpegのフィルターグラフの各ステップの中間結果をキャッシュする仕組みを検討する。
  * キャッシュ管理の複雑さが増すため、費用対効果を考慮する。
  * キャッシュの永続化とクリーンアップ戦略（例: LRUキャッシュ、一定期間経過後の削除）を導入する。
* **確認方法**:

  * 特定のフィルター処理の再実行がスキップされる。

---

### 10. **FFmpegのバージョンアップと機能活用**

* **背景**: 最新のFFmpegにはパフォーマンス向上に寄与する新しい機能や最適化が含まれている可能性がある。
* **ゴール**: 最新のFFmpegの機能を活用し、パフォーマンスを向上させる。
* **実装イメージ**:

  * 最新のFFmpegのリリースノートやドキュメントを定期的に確認し、パフォーマンス向上に寄与する新しいフィルター、エンコーダ、または最適化オプションがないか調査する。
  * 特に、ハードウェアアクセラレーションやGPUフィルターに関する改善に注目する。
* **確認方法**:

  * 新しいFFmpeg機能の導入により、処理速度が向上する。

---

### 11. **Pythonの非同期処理の徹底**

* **背景**: プロジェクト全体で非同期処理が徹底されていない部分があり、I/Oバウンドな処理がブロックされる可能性がある。
* **ゴール**: プロジェクト全体で非同期処理を徹底し、I/Oバウンドな処理がブロックされないようにする。
* **実装イメージ**:

  * I/Oバウンドな処理（ファイルI/O、ネットワークI/O、外部プロセス呼び出し）を特定し、`asyncio` を利用した非同期処理に置き換える。
  * 特に、FFmpegの呼び出しは時間がかかるため、`asyncio.create_subprocess_exec` を適切に利用し、メインスレッドをブロックしないようにする。
* **確認方法**:

  * 全体的な処理速度が向上し、UIの応答性が改善される。

---
